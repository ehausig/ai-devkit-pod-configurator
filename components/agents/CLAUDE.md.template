# Universal Development Guidelines

## Communication Style

Please communicate in a conversational, helpful manner similar to Claude chat. Be clear and informative while maintaining a friendly tone. Provide context for decisions and explain complex concepts when needed.

## Code Philosophy

### General Principles
- **Start Simple**: Write the simplest solution that works correctly
- **Iterate Thoughtfully**: Only add abstractions when complexity demands it
- **Be Idiomatic**: Follow the conventions and patterns of the language
- **Clarity First**: Readable code is better than clever code

### General Development Approach
- Test and commit frequently
- Do not push commits until unit and integration tests succeed
- Create and test APIs before creating and testing UIs
- Use language-appropriate testing framework for unit tests
- Use `expect` scripts and `tmux` for integration and TUI tests
- Avoid premature optimization and over-engineering
- Create parent folder with `mkdir -p` before creating file
- Avoid permissions errors creating files by using `touch` to create file, then Read(), then Edit()
- Avoid permissions errors editing files by first using Read() and then Edit()
- Never create or edit files above the `~/workspace/` or `/home/devuser/workspace` directory
- Create and append to a ~/workspace/JOURNAL.md file key decisions, milestones, and blockers as you work

### Code Quality
- Use descriptive, meaningful variable and function names
- Follow language-specific naming conventions and be idiomatic
- Add comments for complex algorithms or business logic
- Keep functions focused and reasonably sized
- Handle errors appropriately for the language and context

## Project Structure

### Workspace Organization
- The `~/workspace` directory contains individual project folders
- Each project should have its own subdirectory under `~/workspace`
- Initialize git repositories at the project root level (e.g., `~/workspace/my-project/`), never directly in `~/workspace`
- Follow language-specific conventions for internal project structure

### Example Structure:
```
~/workspace/
├── project-one/
│   ├── .git/
│   ├── README.md
│   └── [language-specific structure]
├── project-two/
│   ├── .git/
│   ├── README.md
│   └── [language-specific structure]
└── experiments/
    └── [unversioned experimental code]
```

### Navigation Best Practices
- **Use relative paths**: Navigate with `cd ../project` instead of `/home/devuser/workspace/project`
- **Stay within workspace**: All project work should be under `~/workspace/`
- **Avoid absolute paths**: Security model prevents absolute path navigation

## Documentation Standards

### README.md Template
Create a README.md with the following initial structure:

```markdown
# Project Name

Brief description of what this project does and why it exists.

## Getting Started

### Prerequisites
- List any requirements

### Installation
\```bash
# Installation commands
\```

### Usage
\```bash
# Basic usage examples
\```

## Development

### Setup
Steps for development environment setup

### Testing
How to run tests

### Contributing
<!-- Guidelines for contributing to the project -->

## API Documentation
<!-- API endpoint documentation -->

## Deployment
<!-- Deployment instructions and considerations -->

## License

[License type] - see LICENSE file for details
```

### Documentation Guidelines
- Start with a minimal README.md and expand as the project matures
- Document complex algorithms inline with clear comments
- Use language-specific documentation formats (JSDoc, docstrings, etc.)

## Security Considerations

### File System Access
- Do not attempt to access the host file system outside the container
- If a task requires access outside ~, explain the limitation and suggest alternatives

### General Security Practices
- Never commit sensitive information (API keys, passwords, tokens)
- Use environment variables for configuration secrets
- Validate and sanitize all user inputs
- Follow OWASP guidelines for web applications
- Keep dependencies updated for security patches

## Dependency Management

### Philosophy
- **Start Minimal**: Only add dependencies that provide substantial value
- **Security First**: Regularly audit dependencies for known vulnerabilities
- **Version Stability**: Pin exact versions in lock files for reproducibility
- **Regular Maintenance**: Update dependencies periodically, testing thoroughly
- **License Compliance**: Ensure all dependencies are compatible with project license
- **Prefer Standard**: Use language standard library when reasonable

### Guidelines
- Document why each dependency is needed
- Evaluate the maintenance status of dependencies
- Consider the size and complexity added by each dependency
- Group dependency updates into logical commits
- **Check compatibility first**: Verify version compatibility before adding dependencies
- **Test after adding**: Always run tests after adding new dependencies

## Code Review Preferences

When reviewing code changes:
- **Correctness**: Ensure the code does what it's supposed to do
- **Readability**: Code should be clear and self-documenting
- **Maintainability**: Consider future developers (including yourself)
- **Testing**: Verify adequate test coverage for new functionality and that all the tests have succeeded
- **Security**: Look for potential vulnerabilities or unsafe practices
- **Performance**: Flag obvious performance issues, but avoid premature optimization
- **Conventions**: Ensure consistency with project standards

Provide constructive feedback with specific suggestions for improvement.

## Git Approach

### Git Commit Conventions

Follow the Conventional Commits specification (https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

#### Allowed Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation only changes
- `style`: Changes that don't affect code meaning (formatting, missing semicolons, etc.)
- `refactor`: Code change that neither fixes a bug nor adds a feature
- `perf`: Performance improvements
- `test`: Adding or updating tests
- `chore`: Changes to build process, auxiliary tools, or maintenance tasks
- `ci`: Changes to CI configuration files and scripts
- `build`: Changes affecting build system or external dependencies

#### Guidelines:
- Subject line: max 50 characters, imperative mood ("add" not "added")
- Body: wrap at 72 characters, explain what and why (not how)
- Footer: reference issues, breaking changes with `BREAKING CHANGE:`
- Scope is optional but encouraged when relevant

#### Examples:
```
feat(auth): add OAuth2 integration

Implement OAuth2 flow for third-party authentication providers.
Supports Google and GitHub initially.

Closes #123
```

```
fix: prevent race condition in data sync

The synchronization logic now uses proper mutex locking to prevent
concurrent writes to the shared data structure.
```

### Branch Naming Convention
Use descriptive branch names that align with the change type:
- `feat/short-description` - New features
- `fix/issue-number-description` - Bug fixes (e.g., `fix/123-login-error`)
- `chore/description` - Maintenance tasks
- `docs/description` - Documentation updates
- `refactor/description` - Code refactoring
- `test/description` - Test additions or updates

### New GitHub Repositories

- **LICENSE**: If user does not provide a LICENSE, use `gh repo create --license MIT` to create the repo
- **Enable Auto-merge**: Allow PRs to be automatically merged when checks pass
   ```bash
   gh repo edit --enable-auto-merge
   ```
- **Disable PR approval requirements** for personal/development repos:
   ```bash
   # Via GitHub UI: Settings → Branches → Edit protection rules
   # Uncheck "Require pull request reviews before merging"
   # Or set "Required approving reviews" to 0
   ```

### Pull Request Template
When creating PRs, include:
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix (non-breaking change fixing an issue)
- [ ] New feature (non-breaking change adding functionality)
- [ ] Breaking change (fix or feature causing existing functionality to change)
- [ ] Documentation update

## Testing
- [ ] Tests pass locally
- [ ] Added new tests for new functionality
- [ ] Existing tests updated as needed

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex logic
- [ ] Documentation updated if needed

## Related Issues
Closes #(issue number)
```

## Testing and Automation

### Testing Philosophy
**All tests must pass before pushing to GitHub.** Use a polyglot testing approach that combines:
- **Unit tests**: Language-specific testing frameworks for isolated component testing
- **Integration tests**: Cross-language tools (`expect`, `tmux`, `curl`) for end-to-end testing
- **Continuous testing**: Run tests frequently during development, not just before commits

### Cross-Language Testing Tools

#### Integration Testing with Expect

For interactive programs (TUIs, CLIs, REPLs), create expect scripts:

```tcl
#!/usr/bin/expect -f
# Example: tests/integration/test_cli.exp
set timeout 10
log_file tests/integration/test_cli.log

spawn ./myapp --interactive
expect {
    "Welcome" { 
        send "help\r"
        exp_continue
    }
    "Commands:" {
        send "status\r"
        exp_continue
    }
    "Status: OK" {
        send "exit\r"
    }
    timeout {
        puts "FAIL: CLI test timeout"
        exit 1
    }
}
expect eof
puts "PASS: CLI basic functionality"
```

#### TUI Testing with tmux

For complex TUI applications:

```bash
#!/bin/bash
# tests/integration/test_tui_tmux.sh

tmux new-session -d -s test_session './myapp'
sleep 1

# Send keystrokes
tmux send-keys -t test_session Down Enter
sleep 0.5

# Capture and verify screen
tmux capture-pane -t test_session -p > output.txt
if grep -q "Expected Menu Item" output.txt; then
    echo "PASS: Menu navigation"
else
    echo "FAIL: Menu navigation"
    tmux kill-session -t test_session
    exit 1
fi

tmux kill-session -t test_session
```

#### API Testing with curl

For HTTP APIs:

```bash
#!/bin/bash
# tests/integration/test_api.sh

BASE_URL="http://localhost:8080"

# Test health endpoint
response=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/health")
if [ "$response" = "200" ]; then
    echo "PASS: Health check"
else
    echo "FAIL: Health check (HTTP $response)"
    exit 1
fi
```

### Test Organization

```
tests/
├── unit/           # Language-specific unit tests
├── integration/    # Cross-language integration tests
│   ├── test_cli_basic.exp
│   ├── test_tui_navigation.exp
│   └── test_api_flow.sh
└── run_all_tests.sh
```

### Pre-Push Testing Workflow

Create a universal test runner that detects the project type and runs appropriate tests:

```bash
#!/bin/bash
# run_all_tests.sh

set -e  # Exit on first failure

echo "Running tests..."

# Language-specific unit tests will be detected and run based on project files
# Integration tests are universal
for test in tests/integration/*.exp; do
    [ -f "$test" ] || continue
    echo "Running: $test"
    expect "$test" || exit 1
done

for test in tests/integration/*.sh; do
    [ -f "$test" ] || continue
    echo "Running: $test"
    bash "$test" || exit 1
done

echo "All tests passed! Ready to push."
```

### Best Practices

1. **Write tests first**: Create integration test scripts before implementing features
2. **Test immediately**: Run tests after every significant change
3. **Automate everything**: If you test it manually twice, write a test script
4. **Use tmux for complex TUIs**: Better screen capture and control
5. **Log test output**: Use `log_file` in expect scripts for debugging
6. **Version control tests**: Commit test scripts with the code they test

## Common Development Blockers and Solutions

Based on real-world experience, here are common issues and their solutions:

### 1. Environment Activation Issues
**Problem**: Standard activation commands fail
**Solution**:
- Check language-specific memory_content for environment-specific solutions
- Test environment commands before building workflows around them

### 2. Path Navigation Restrictions
**Problem**: Security model blocks absolute paths
**Solution**:
- Use relative paths: `cd ../other-project` instead of `/home/devuser/workspace/other-project`
- Stay within ~/workspace/ for all project work
- Use `pwd` to verify current location

### 3. Dependency Version Conflicts
**Problem**: Incompatible versions between related packages
**Solution**: 
- Check language-specific memory_content for known compatibility issues
- Test immediately after adding dependencies

### 4. Testing Delays
**Problem**: Creating tests but not running them immediately
**Solution**:
- Run tests as part of the development flow
- Use language-specific watch modes when available
- Create simple smoke tests first to verify setup

<!-- ENVIRONMENT_TOOLS_MARKER -->
<!-- This section will be automatically appended with language-specific guidelines -->
<!-- Do not edit below this line -->

---
*Note: Language-specific configurations and tooling preferences will be automatically appended below by the setup script.*
