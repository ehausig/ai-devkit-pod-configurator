# Universal Development Guidelines

## Communication Style

Please communicate in a conversational, helpful manner similar to Claude chat. Be clear and informative while maintaining a friendly tone. Provide context for decisions and explain complex concepts when needed.

## Code Philosophy

### General Principles
- **Start Simple**: Write the simplest solution that works correctly
- **Iterate Thoughtfully**: Only add abstractions when complexity demands it
- **Be Idiomatic**: Follow the conventions and patterns of the language
- **Clarity First**: Readable code is better than clever code

### General Development Approach
- Test and commit frequently
- Do not push commits until unit and integration tests succeed
- Create and test APIs before creating and testing UIs
- Use language-appropriate testing framework for unit tests
- Use `expect` scripts and `tmux` for integration and TUI tests
- Avoid premature optimization and over-engineering
- Create parent folder with `mkdir -p` before creating file
- Avoid permissions errors creating files by using `touch` to create file, then Read(), then Edit()
- Avoid permissions errors editing files by first using Read() and then Edit()
- Never create or edit files above the `~/workspace/` or `/home/devuser/workspace` directory
- Create and append to a ~/workspace/JOURNAL.md file key decisions, milestones, and blockers as you work

### Code Quality
- Use descriptive, meaningful variable and function names
- Follow language-specific naming conventions and be idiomatic
- Add comments for complex algorithms or business logic
- Keep functions focused and reasonably sized
- Handle errors appropriately for the language and context

## Project Structure

### Workspace Organization
- The `~/workspace` directory contains individual project folders
- Each project should have its own subdirectory under `~/workspace`
- Initialize git repositories at the project root level (e.g., `~/workspace/my-project/`), never directly in `~/workspace`
- Follow language-specific conventions for internal project structure

### Example Structure:
```
~/workspace/
├── project-one/
│   ├── .git/
│   ├── README.md
│   └── [language-specific structure]
├── project-two/
│   ├── .git/
│   ├── README.md
│   └── [language-specific structure]
└── experiments/
    └── [unversioned experimental code]
```

### Navigation Best Practices
- **Use relative paths**: Navigate with `cd ../project` instead of `/home/devuser/workspace/project`
- **Stay within workspace**: All project work should be under `~/workspace/`
- **Avoid absolute paths**: Security model prevents absolute path navigation

## Documentation Standards

### README.md Template
Create a README.md with the following initial structure:

```markdown
# Project Name

Brief description of what this project does and why it exists.

## Getting Started

### Prerequisites
- List any requirements

### Installation
\```bash
# Installation commands
\```

### Usage
\```bash
# Basic usage examples
\```

## Development

### Setup
Steps for development environment setup

### Testing
How to run tests

### Contributing
<!-- Guidelines for contributing to the project -->

## API Documentation
<!-- API endpoint documentation -->

## Deployment
<!-- Deployment instructions and considerations -->

## License

[License type] - see LICENSE file for details
```

### Documentation Guidelines
- Start with a minimal README.md and expand as the project matures
- Document complex algorithms inline with clear comments
- Use language-specific documentation formats (JSDoc, docstrings, etc.)

## Security Considerations

### File System Access
- Do not attempt to access the host file system outside the container
- If a task requires access outside ~, explain the limitation and suggest alternatives

### General Security Practices
- Never commit sensitive information (API keys, passwords, tokens)
- Use environment variables for configuration secrets
- Validate and sanitize all user inputs
- Follow OWASP guidelines for web applications
- Keep dependencies updated for security patches

## Dependency Management

### Philosophy
- **Start Minimal**: Only add dependencies that provide substantial value
- **Security First**: Regularly audit dependencies for known vulnerabilities
- **Version Stability**: Pin exact versions in lock files for reproducibility
- **Regular Maintenance**: Update dependencies periodically, testing thoroughly
- **License Compliance**: Ensure all dependencies are compatible with project license
- **Prefer Standard**: Use language standard library when reasonable

### Guidelines
- Document why each dependency is needed
- Evaluate the maintenance status of dependencies
- Consider the size and complexity added by each dependency
- Group dependency updates into logical commits
- **Check compatibility first**: Verify version compatibility before adding dependencies
- **Test after adding**: Always run tests after adding new dependencies

## Code Review Preferences

When reviewing code changes:
- **Correctness**: Ensure the code does what it's supposed to do
- **Readability**: Code should be clear and self-documenting
- **Maintainability**: Consider future developers (including yourself)
- **Testing**: Verify adequate test coverage for new functionality and that all the tests have succeeded
- **Security**: Look for potential vulnerabilities or unsafe practices
- **Performance**: Flag obvious performance issues, but avoid premature optimization
- **Conventions**: Ensure consistency with project standards

Provide constructive feedback with specific suggestions for improvement.

## Git Approach

### Git Commit Conventions

Follow the Conventional Commits specification (https://www.conventionalcommits.org/):

```
<type>(<scope>): <subject>

<body>

<footer>
```

#### Allowed Types:
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation only changes
- `style`: Changes that don't affect code meaning (formatting, missing semicolons, etc.)
- `refactor`: Code change that neither fixes a bug nor adds a feature
- `perf`: Performance improvements
- `test`: Adding or updating tests
- `chore`: Changes to build process, auxiliary tools, or maintenance tasks
- `ci`: Changes to CI configuration files and scripts
- `build`: Changes affecting build system or external dependencies

#### Guidelines:
- Subject line: max 50 characters, imperative mood ("add" not "added")
- Body: wrap at 72 characters, explain what and why (not how)
- Footer: reference issues, breaking changes with `BREAKING CHANGE:`
- Scope is optional but encouraged when relevant

#### Examples:
```
feat(auth): add OAuth2 integration

Implement OAuth2 flow for third-party authentication providers.
Supports Google and GitHub initially.

Closes #123
```

```
fix: prevent race condition in data sync

The synchronization logic now uses proper mutex locking to prevent
concurrent writes to the shared data structure.
```

### Branch Naming Convention
Use descriptive branch names that align with the change type:
- `feat/short-description` - New features
- `fix/issue-number-description` - Bug fixes (e.g., `fix/123-login-error`)
- `chore/description` - Maintenance tasks
- `docs/description` - Documentation updates
- `refactor/description` - Code refactoring
- `test/description` - Test additions or updates

### New GitHub Repositories

- **LICENSE**: If user does not provide a LICENSE, use `gh repo create --license MIT` to create the repo
- **Enable Auto-merge**: Allow PRs to be automatically merged when checks pass
   ```bash
   gh repo edit --enable-auto-merge
   ```
- **Disable PR approval requirements** for personal/development repos:
   ```bash
   # Via GitHub UI: Settings → Branches → Edit protection rules
   # Uncheck "Require pull request reviews before merging"
   # Or set "Required approving reviews" to 0
   ```

### Pull Request Template
When creating PRs, include:
```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix (non-breaking change fixing an issue)
- [ ] New feature (non-breaking change adding functionality)
- [ ] Breaking change (fix or feature causing existing functionality to change)
- [ ] Documentation update

## Testing
- [ ] Tests pass locally
- [ ] Added new tests for new functionality
- [ ] Existing tests updated as needed

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Comments added for complex logic
- [ ] Documentation updated if needed

## Related Issues
Closes #(issue number)
```

## Testing and Automation

### Testing Philosophy
**All tests must pass before pushing to GitHub.** Use a polyglot testing approach:
- **Unit tests**: Language-specific testing frameworks
- **Integration tests**: `expect`, `tmux`, and `curl` for cross-language compatibility
- **TUI/CLI tests**: `expect` scripts for interactive program testing
- **API tests**: `curl` for HTTP endpoints, `expect` for interactive clients

### Language-Specific Unit Testing

Use the idiomatic testing framework for each language:

**Python**:
```bash
# pytest for unit tests
pytest tests/
# or unittest
python -m unittest discover
```

**JavaScript/TypeScript**:
```bash
# Jest or Vitest
npm test
# or
yarn test
```

**Rust**:
```bash
cargo test
```

**Go**:
```bash
go test ./...
```

**Java**:
```bash
# JUnit with Maven
mvn test
# or with Gradle
gradle test
```

**Ruby**:
```bash
# RSpec
rspec
# or Minitest
ruby -Ilib:test test/test_*.rb
```

### Integration Testing with Expect

For any interactive programs (TUIs, CLIs, REPLs), create expect scripts:

```bash
# Directory structure
tests/
├── unit/           # Language-specific unit tests
├── integration/    # Expect scripts for integration tests
│   ├── test_cli_basic.exp
│   ├── test_tui_navigation.exp
│   └── test_api_flow.exp
└── run_all_tests.sh
```

**Example integration test** (`tests/integration/test_cli.exp`):
```tcl
#!/usr/bin/expect -f
set timeout 10
log_file tests/integration/test_cli.log

# Test CLI basic functionality
spawn ./myapp --interactive
expect {
    "Welcome" { 
        send "help\r"
        exp_continue
    }
    "Commands:" {
        send "status\r"
        exp_continue
    }
    "Status: OK" {
        send "exit\r"
    }
    timeout {
        puts "FAIL: CLI test timeout"
        exit 1
    }
}
expect eof
puts "PASS: CLI basic functionality"
```

### TUI Testing with tmux

For complex TUI applications, combine tmux with expect:

```bash
#!/bin/bash
# tests/integration/test_tui_tmux.sh

# Start TUI in tmux
tmux new-session -d -s test_session 'python tui_app.py'
sleep 1

# Send keystrokes
tmux send-keys -t test_session Down Enter
sleep 0.5

# Capture and verify screen
tmux capture-pane -t test_session -p > output.txt
if grep -q "Expected Menu Item" output.txt; then
    echo "PASS: Menu navigation"
else
    echo "FAIL: Menu navigation"
    tmux kill-session -t test_session
    exit 1
fi

tmux kill-session -t test_session
```

### API Testing with curl

For HTTP APIs, create curl-based test scripts:

```bash
#!/bin/bash
# tests/integration/test_api.sh

BASE_URL="http://localhost:8080"

# Test health endpoint
response=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/health")
if [ "$response" = "200" ]; then
    echo "PASS: Health check"
else
    echo "FAIL: Health check (HTTP $response)"
    exit 1
fi

# Test API endpoint with data
response=$(curl -s -X POST "$BASE_URL/api/users" \
    -H "Content-Type: application/json" \
    -d '{"name":"test","email":"test@example.com"}')

if echo "$response" | grep -q '"id"'; then
    echo "PASS: User creation"
else
    echo "FAIL: User creation"
    exit 1
fi
```

### Pre-Push Testing Workflow

**Always run this before pushing**:

```bash
#!/bin/bash
# run_all_tests.sh

set -e  # Exit on first failure

echo "Running unit tests..."
case "$(ls -1 | grep -E 'Cargo.toml|package.json|go.mod|pom.xml|Gemfile|setup.py|requirements.txt' | head -1)" in
    "Cargo.toml")
        cargo test
        ;;
    "package.json")
        npm test
        ;;
    "go.mod")
        go test ./...
        ;;
    "pom.xml")
        mvn test
        ;;
    "Gemfile")
        bundle exec rspec
        ;;
    *".py"|"requirements.txt"|"setup.py")
        pytest || python -m unittest discover
        ;;
esac

echo "Running integration tests..."
for test in tests/integration/*.exp; do
    [ -f "$test" ] || continue
    echo "Running: $test"
    expect "$test" || exit 1
done

# Run shell-based integration tests
for test in tests/integration/*.sh; do
    [ -f "$test" ] || continue
    echo "Running: $test"
    bash "$test" || exit 1
done

echo "All tests passed! Ready to push."
```

### Git Hook for Test Enforcement

Install a pre-push hook to ensure tests run:

```bash
#!/bin/bash
# .git/hooks/pre-push

echo "Running tests before push..."
./run_all_tests.sh || {
    echo "Tests failed! Push aborted."
    echo "Fix the failing tests before pushing."
    exit 1
}
```

### Best Practices

1. **Write tests first**: Create expect scripts before implementing features
2. **Test immediately**: Run tests after every significant change
3. **Automate everything**: If you test it manually twice, write an expect script
4. **Use tmux for complex TUIs**: Better screen capture and control
5. **Log test output**: Use `log_file` in expect scripts for debugging
6. **Version control tests**: Commit test scripts with the code they test
7. **Document test requirements**: Include test running instructions in README

### Example Development Flow

```bash
# 1. Create feature branch
git checkout -b feat/new-tui-menu

# 2. Write integration test first
cat > tests/integration/test_new_menu.exp << 'EOF'
#!/usr/bin/expect -f
spawn python app.py
expect "Main Menu"
send "3\r"  # Select new option
expect "New Feature"
send "q\r"  # Quit
expect eof
EOF
chmod +x tests/integration/test_new_menu.exp

# 3. Run test (it should fail)
expect tests/integration/test_new_menu.exp

# 4. Implement feature
# ... code changes ...

# 5. Run all tests
./run_all_tests.sh

# 6. Commit with tests
git add .
git commit -m "feat: add new menu option with integration tests"

# 7. Push (pre-push hook ensures tests pass)
git push origin feat/new-tui-menu
```

This polyglot approach ensures consistent testing across all languages while leveraging the best tools for each testing scenario.

## Common Development Blockers and Solutions

Based on real-world experience, here are common issues and their solutions:

### 1. Dependency Version Conflicts
**Problem**: Incompatible versions between related packages
**Solution**: 
- Check compatibility before adding dependencies
- Use `cargo tree -d` (Rust) or `npm ls` (Node.js) to identify conflicts
- Pin specific versions when mixing async crates or complex dependencies

### 2. Environment Activation Issues
**Problem**: Standard activation commands fail (e.g., conda activate)
**Solution**:
- For conda: Use `eval "$(conda shell.bash hook)"` before activate
- For Python venv: Always use `source .venv/bin/activate`
- Test environment commands before building workflows around them

### 3. Path Navigation Restrictions
**Problem**: Security model blocks absolute paths
**Solution**:
- Use relative paths: `cd ../other-project` instead of `/home/devuser/workspace/other-project`
- Stay within ~/workspace/ for all project work
- Use `pwd` to verify current location

### 4. Missing Dependencies
**Problem**: Forgetting commonly needed but not obvious dependencies
**Common misses**:
- Rust: `async-trait` when using async traits
- Python: Development tools (black, ruff, mypy)
- Node.js: Testing frameworks (jest, supertest)

### 5. Testing Delays
**Problem**: Creating tests but not running them immediately
**Solution**:
- Run tests as part of the development flow
- Use watch modes: `cargo watch -x test`, `npm run test:watch`
- Create simple "hello world" tests first to verify setup

<!-- ENVIRONMENT_TOOLS_MARKER -->
<!-- This section will be automatically appended with language-specific guidelines -->
<!-- Do not edit below this line -->

---
*Note: Language-specific configurations and tooling preferences will be automatically appended below by the setup script.*
