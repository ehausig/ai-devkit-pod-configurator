id: JAVA_21_ADOPTIUM
name: Java 21 (Eclipse Adoptium)
group: java-version
requires: []
description: Eclipse Adoptium (formerly AdoptOpenJDK) Temurin 21
installation:
  dockerfile: |
    # Pass Nexus configuration to this build stage
    ARG USE_NEXUS_APT
    ARG NEXUS_APT_URL
    RUN export DEBIAN_FRONTEND=noninteractive && \
        apt-get update && \
        apt-get install -y wget apt-transport-https gnupg && \
        mkdir -p /etc/apt/keyrings && \
        wget -qO - https://packages.adoptium.net/artifactory/api/gpg/key/public | tee /etc/apt/keyrings/adoptium.asc > /dev/null && \
        if [ -n "$USE_NEXUS_APT" ] && [ -n "$NEXUS_APT_URL" ]; then \
            echo "deb [signed-by=/etc/apt/keyrings/adoptium.asc] ${NEXUS_APT_URL}/repository/adoptium-apt-proxy $(awk -F= '/^VERSION_CODENAME/{print$2}' /etc/os-release) main" | tee /etc/apt/sources.list.d/adoptium.list; \
        else \
            echo "deb [signed-by=/etc/apt/keyrings/adoptium.asc] https://packages.adoptium.net/artifactory/deb $(awk -F= '/^VERSION_CODENAME/{print$2}' /etc/os-release) main" | tee /etc/apt/sources.list.d/adoptium.list; \
        fi && \
        apt-get update && \
        apt-get install -y temurin-21-jdk && \
        rm -rf /var/lib/apt/lists/*
  env:
    - JAVA_HOME=/usr/lib/jvm/temurin-21-jdk-${TARGETARCH}
  test_command: java -version
entrypoint_setup: |
  # Java 21 Adoptium specific setup
  echo "Setting up Java 21 Adoptium environment..."
  
  # Set JAVA_HOME for the user
  if ! grep -q "JAVA_HOME" "$BASHRC" 2>/dev/null; then
      echo '' >> "$BASHRC"
      echo '# Java environment' >> "$BASHRC"
      echo 'export JAVA_HOME=/usr/lib/jvm/temurin-21-jdk-'$(dpkg --print-architecture) >> "$BASHRC"
      echo 'export PATH="$JAVA_HOME/bin:$PATH"' >> "$BASHRC"
  fi
memory_content: |
  #### Java 21 (Eclipse Adoptium Temurin) - Latest LTS
  
  **Environment**:
  - Java version: `java -version`
  - JAVA_HOME: Pre-configured at `/usr/lib/jvm/temurin-21-jdk-${TARGETARCH}`
  
  **Java 21 Highlights**:
  - Virtual threads: `Thread.ofVirtual().start(() -> {})` for massive concurrency
  - Pattern matching: Complete with record patterns in switch
  - Sequenced collections: `List.reversed()`, `Map.firstEntry()`
  - String templates (preview): Better string interpolation
  
  **Virtual Threads Example**:
  ```java
  // Handle thousands of concurrent requests efficiently
  try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
      IntStream.range(0, 10_000).forEach(i -> 
          executor.submit(() -> {
              // Each runs in a virtual thread
              processRequest(i);
          })
      );
  }
  ```
  
  **Unit Testing with Virtual Threads**:
  ```java
  @Test
  void testConcurrentRequests() throws Exception {
      try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
          var futures = IntStream.range(0, 1000)
              .mapToObj(i -> executor.submit(() -> makeRequest()))
              .toList();
          
          // Wait for all to complete
          futures.forEach(f -> assertDoesNotThrow(f::get));
      }
  }
  ```
  
  **Modern API Development**:
  ```java
  // Using virtual threads with HTTP server
  var server = HttpServer.create(new InetSocketAddress(8080), 0);
  server.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
  server.createContext("/api", exchange -> {
      // Runs in virtual thread
      handleRequest(exchange);
  });
  server.start();
  ```
  
  **Performance Tips**:
  - Use G1GC (default): Balanced for most workloads
  - For low latency: `java -XX:+UseZGC MyApp`
  - For throughput: `java -XX:+UseParallelGC MyApp`
  
  **Testing Best Practices**:
  - Test with thousands of virtual threads
  - Use JUnit 5.10+ for better virtual thread support
  - Profile with JFR to understand thread behavior
  
  **Migration Tips**:
  - Virtual threads are drop-in replacements for platform threads
  - No pooling needed - create as many as you want
  - Ideal for I/O-bound workloads
  - Avoid synchronized blocks in hot paths
